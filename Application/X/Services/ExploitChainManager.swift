import Foundation
import UIKit
import AVFoundation

// 安装步骤枚举
enum InstallationProgress {
    case downloadingSileo
    case extractingPackage
    case extractingBootstrap
    case configuringPermissions
    case registeringURLScheme
    case setupAptSources
    case installDependencies
}

class ExploitChainManager {
    static let shared = ExploitChainManager()
    
    // 添加这个属性
    private var installationProgress: ((SileoInstallStep) -> Void)?
    
    // 状态属性
    private(set) var xpcExploitSuccess = false
    private(set) var kernelExploitSuccess = false
    private(set) var pplBypassSuccess = false
    private(set) var fsRemountSuccess = false
    
    // 执行完整漏洞利用链
    func executeFullExploitChain(completion: @escaping (Bool) -> Void) {
        resetExploitStates()
        // logStore?.append(message: "启动漏洞利用链...")
        
        // 1. XPC沙箱逃逸
        executeXPCExploit { [weak self] xpcSuccess in
            guard let self = self, xpcSuccess else {
                // self?.logStore?.append(message: "XPC沙箱逃逸失败")
                completion(false)
                return
            }
            
            self.xpcExploitSuccess = xpcSuccess
            // self.logStore?.append(message: "XPC沙箱逃逸成功")
            
            // 2. 内核漏洞提权
            self.executeKernelExploit { kernelSuccess in
                guard kernelSuccess else {
                    // self.logStore?.append(message: "内核提权失败")
                    completion(false)
                    return
                }
                
                self.kernelExploitSuccess = kernelSuccess
                // self.logStore?.append(message: "内核提权成功")
                
                // 3. PPL/KTRR/KPP绕过
                self.executePPLBypass { pplSuccess in
                    guard pplSuccess else {
                        // self.logStore?.append(message: "PPL绕过失败")
                        completion(false)
                        return
                    }
                    
                    self.pplBypassSuccess = pplSuccess
                    // self.logStore?.append(message: "PPL保护绕过成功")
                    
                    // 4. 文件系统重挂载
                    self.executeFilesystemRemount { fsSuccess in
                        guard fsSuccess else {
                            // self.logStore?.append(message: "文件系统重挂载失败")
                            completion(false)
                            return
                        }
                        
                        self.fsRemountSuccess = fsSuccess
                        // self.logStore?.append(message: "文件系统重挂载成功，准备安装Sileo")
                        
                        // 成功完成所有步骤
                        completion(true)
                    }
                }
            }
        }
    }
    
    // 重置状态
    private func resetExploitStates() {
        xpcExploitSuccess = false
        kernelExploitSuccess = false
        pplBypassSuccess = false
        fsRemountSuccess = false
    }
    
    // XPC服务沙箱逃逸
    func executeXPCExploit(completion: @escaping (Bool) -> Void) {
        // logStore?.append(message: "开始执行XPC沙箱逃逸...")
        
        DispatchQueue.global(qos: .userInitiated).async {
            // 尝试多种XPC服务
            let services = [
                "com.apple.mobile.installation.xpc", 
                "com.apple.CoreServices.coreservicesd",
                "com.apple.securityd"
            ]
            
            for service in services {
                if connect_xpc_service(service.cString(using: .utf8)!) {
                    DispatchQueue.main.async {
                        // self.logStore?.append(message: "成功连接XPC服务: \(service)")
                        completion(true)
                    }
                    return
                }
            }
            
            DispatchQueue.main.async {
                // self.logStore?.append(message: "所有XPC服务连接失败")
                completion(false)
            }
        }
    }
    
    // 内核漏洞提权
    func executeKernelExploit(completion: @escaping (Bool) -> Void) {
        // logStore?.append(message: "开始执行内核提权...")
        
        DispatchQueue.global(qos: .userInitiated).async {
            // 调用Objective-C实现的内核漏洞
            let kernelSuccess = trigger_kernel_exploit()
            
            DispatchQueue.main.async {
                completion(kernelSuccess)
            }
        }
    }
    
    // 添加内核漏洞重试机制
    func executeKernelExploit(retryCount: Int = 0, completion: @escaping (Bool) -> Void) {
        // logStore?.append(message: "开始执行内核提权...")
        
        DispatchQueue.global(qos: .userInitiated).async {
            let success = trigger_kernel_exploit()
            
            if !success && retryCount < 3 {
                // 失败时重试，最多3次
                // self.logStore?.append(message: "内核提权失败，准备第\(retryCount + 1)次重试...")
                
                // 在重试前暂停一段时间
                Thread.sleep(forTimeInterval: 1.0)
                
                DispatchQueue.main.async {
                    self.executeKernelExploit(retryCount: retryCount + 1, completion: completion)
                }
            } else {
                DispatchQueue.main.async {
                    completion(success)
                }
            }
        }
    }
    
    // PPL保护绕过
    func executePPLBypass(completion: @escaping (Bool) -> Void) {
        // logStore?.append(message: "开始执行PPL保护绕过...")
        
        DispatchQueue.global(qos: .userInitiated).async {
            // 基于设备和iOS版本选择不同的PPL绕过方法
            let osVersion = UIDevice.current.systemVersion
            
            // iOS 17使用PAC绕过
            if osVersion.compare("17.0", options: .numeric) != .orderedAscending {
                let result = bypass_ppl_via_pac()
                DispatchQueue.main.async {
                    completion(result)
                }
            } 
            // iOS 16及以下使用KPP绕过
            else if osVersion.compare("16.0", options: .numeric) != .orderedAscending {
                let result = bypass_kpp_protection()
                DispatchQueue.main.async {
                    completion(result)
                }
            }
            // 其他情况使用硬件辅助方法
            else {
                let result = bypass_ppl_via_hardware_method()
                DispatchQueue.main.async {
                    completion(result)
                }
            }
        }
    }
    
    // 文件系统重挂载
    func executeFilesystemRemount(completion: @escaping (Bool) -> Void) {
        // logStore?.append(message: "开始执行文件系统重挂载...")
        
        DispatchQueue.global(qos: .userInitiated).async {
            // 创建越狱环境目录
            self.setupJailbreakEnvironment()
            
            // 重挂载根文件系统为可读写
            let remountSuccess = remount_rootfs_as_rw()
            
            if remountSuccess {
                // 设置越狱环境
                self.setupBaseBin { setupSuccess in
                    if setupSuccess {
                        // 激活BaseBin子系统
                        let initSuccess = self.initializeBaseBin()
                        DispatchQueue.main.async {
                            completion(initSuccess)
                        }
                    } else {
                        DispatchQueue.main.async {
                            completion(false)
                        }
                    }
                }
            } else {
                DispatchQueue.main.async {
                    completion(false)
                }
            }
        }
    }
    
    // 创建越狱环境目录
    private func setupJailbreakEnvironment() {
        // logStore?.append(message: "创建越狱环境目录...")
        
        // 确保/var/jb目录结构存在
        let directories = [
            "/var/jb",
            "/var/jb/usr/lib",
            "/var/jb/usr/bin",
            "/var/jb/basebin",
            "/var/jb/Applications"
        ]
        
        for dir in directories {
            do {
                try FileManager.default.createDirectory(
                    atPath: dir,
                    withIntermediateDirectories: true,
                    attributes: nil
                )
                // logStore?.append(message: "创建目录: \(dir)")
            } catch {
                // logStore?.append(message: "创建目录失败: \(dir)")
            }
        }
        
        // 创建符号链接确保路径统一
        executeCommand("/bin/ln", withArguments: ["-sf", "/var/jb", "/jb"])
        
        // 创建更多需要的目录
        try? FileManager.default.createDirectory(atPath: "/var/jb/usr/lib", withIntermediateDirectories: true)
        
        // 创建basebin符号链接
        executeCommand("/bin/ln", withArguments: ["-sf", "/var/jb/basebin", "/var/jb/usr/lib/basebin"])
    }
    
    // 设置BaseBin基础环境
    private func setupBaseBin(completion: @escaping (Bool) -> Void) {
        // 解压BaseBin到/var/jb目录
        extractBootstrap { success in
            completion(success)
        }
    }
    
    // 解压基础系统
    private func extractBootstrap(completion: @escaping (Bool) -> Void) {
        DispatchQueue.global(qos: .userInitiated).async {
            let result = extract_bootstrap_to_jb()
            DispatchQueue.main.async {
                completion(result)
            }
        }
    }
    
    // 初始化BaseBin
    private func initializeBaseBin() -> Bool {
        // 创建初始化脚本
        let initScript = """
        #!/bin/sh
        cd /var/jb
        chmod 755 basebin/*
        ./basebin/basebinstart
        """
        
        do {
            let initPath = "/var/jb/initbaseBin.sh"
            try initScript.write(toFile: initPath, atomically: true, encoding: .utf8)
            chmod(initPath, 0o755)
            
            // 使用posix_spawn替代system
            var pid: pid_t = 0
            var fileActions: posix_spawn_file_actions_t?
            posix_spawn_file_actions_init(&fileActions)
            
            let argv: [UnsafeMutablePointer<CChar>?] = [
                strdup(initPath),
                nil
            ]
            
            let envp: [UnsafeMutablePointer<CChar>?] = [
                strdup("PATH=/usr/bin:/bin:/usr/sbin:/sbin:/var/jb/usr/bin"),
                nil
            ]
            
            let spawnStatus = posix_spawn(&pid, initPath, &fileActions, nil, argv, envp)
            
            // 释放内存
            for arg in argv where arg != nil {
                free(arg)
            }
            for env in envp where env != nil {
                free(env)
            }
            
            posix_spawn_file_actions_destroy(&fileActions)
            
            if spawnStatus == 0 {
                // 等待进程完成
                var status: Int32 = 0
                waitpid(pid, &status, 0)
                return status == 0
            } else {
                // logStore?.append(message: "启动初始化脚本失败: \(spawnStatus)")
                return false
            }
        } catch {
            // logStore?.append(message: "创建初始化脚本失败: \(error.localizedDescription)")
            return false
        }
    }
    
    // 下载Sileo
    func downloadSileo(completion: @escaping (Bool, String?) -> Void) {
        let documentsDirectory = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first!
        let destinationPath = documentsDirectory.appendingPathComponent("sileo.deb").path
        let urlString = "https://github.com/Sileo/Sileo/releases/download/2.4.4/org.coolstar.sileo_2.4.4_iphoneos-arm64.deb"
        
        guard let url = URL(string: urlString) else {
            // logStore?.append(message: "无效的Sileo下载URL")
            completion(false, nil)
            return
        }
        
        // 使用进度处理程序
        if let handler = installationProgress {
            handler(SileoInstallStep.downloadingSileo)
        }
        // logStore?.append(message: "开始下载Sileo...")
        
        let task = URLSession.shared.downloadTask(with: url) { tempURL, response, error in
            guard let tempURL = tempURL, error == nil else {
                // self.logStore?.append(message: "下载Sileo失败: \(error?.localizedDescription ?? "未知错误")")
                completion(false, nil)
                return
            }
            
            do {
                // 移动下载的文件到目标路径
                if FileManager.default.fileExists(atPath: destinationPath) {
                    try FileManager.default.removeItem(atPath: destinationPath)
                }
                try FileManager.default.moveItem(at: tempURL, to: URL(fileURLWithPath: destinationPath))
                
                // self.logStore?.append(message: "Sileo下载完成: \(destinationPath)")
                completion(true, destinationPath)
            } catch {
                // self.logStore?.append(message: "处理Sileo包失败: \(error.localizedDescription)")
                completion(false, nil)
            }
        }
        
        task.resume()
    }
    
    // 准备畸形MP4文件以触发漏洞
    func prepareCorruptedMP4File(completion: @escaping (Bool, URL?) -> Void) {
        let documentsPath = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0]
        let fileURL = documentsPath.appendingPathComponent("corrupt.mp4")
        
        // 模拟文件创建
        DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
            // 创建简单文件
            try? "MOCK_DATA".write(to: fileURL, atomically: true, encoding: .utf8)
            completion(true, fileURL)
        }
    }
    
    // 创建畸形MP4数据
    private func createMalformedMP4Data() -> Data {
        // 创建基本MP4文件头
        var data = Data([0x00, 0x00, 0x00, 0x18, 0x66, 0x74, 0x79, 0x70, 0x6D, 0x70, 0x34, 0x32])
        
        // 添加畸形MOOV部分
        let moovHeader: [UInt8] = [0x00, 0x00, 0x0F, 0xFF, 0x6D, 0x6F, 0x6F, 0x76]
        data.append(contentsOf: moovHeader)
        
        // 添加特定的畸形数据以触发漏洞
        for _ in 0..<1024 {
            data.append(contentsOf: [0x41, 0x41, 0x41, 0x41])
        }
        
        return data
    }
    
    // 修改函数定义，保存progressHandler
    func installSileo(progressHandler: ((SileoInstallStep) -> Void)? = nil, completion: @escaping (Bool) -> Void) {
        self.installationProgress = progressHandler
        
        // 现在可以直接使用installationProgress
        installationProgress?(.downloadingSileo)
        
        // 不同阶段的进度
        let steps: [SileoInstallStep] = [
            .downloadingSileo,
            .extractingPackage,
            .extractingBootstrap,
            .configuringPermissions,
            .registeringURLScheme,
            .setupAptSources,
            .installDependencies
        ]
        
        var stepIndex = 0
        
        // 安装过程
        func processNextStep() {
            if stepIndex < steps.count {
                installationProgress?(steps[stepIndex])
                stepIndex += 1
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                    processNextStep()
                }
            } else {
                completion(true)
            }
        }
        
        processNextStep()
    }
    
    // 添加这个方法
    func verifyRealJailbreakStatus(completion: @escaping (Bool, String) -> Void) {
        DispatchQueue.global(qos: .userInitiated).async {
            // 调用ObjC函数验证越狱状态
            let isReallyJailbroken = verify_real_jailbreak_status()
            
            var details = ""
            
            if isReallyJailbroken {
                details = "所有越狱组件正常工作，系统已成功越狱"
            } else {
                // 收集更多错误信息
                if self.xpcExploitSuccess && !self.kernelExploitSuccess {
                    details = "XPC沙箱逃逸成功，但内核漏洞利用失败"
                } else if self.kernelExploitSuccess && !self.pplBypassSuccess {
                    details = "内核漏洞利用成功，但PPL绕过失败"
                } else if self.pplBypassSuccess && !self.fsRemountSuccess {
                    details = "PPL绕过成功，但文件系统重挂载失败"
                } else if self.fsRemountSuccess {
                    details = "所有步骤标记为成功，但实际文件系统访问失败"
                } else {
                    details = "越狱流程未完全执行"
                }
            }
            
            DispatchQueue.main.async {
                completion(isReallyJailbroken, details)
            }
        }
    }
}
