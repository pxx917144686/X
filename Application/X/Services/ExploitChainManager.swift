import Foundation
import UIKit
import AVFoundation

// 安装步骤枚举
enum InstallationProgress {
    case downloadingSileo
    case extractingPackage
    case extractingBootstrap
    case configuringPermissions
    case registeringURLScheme
    case setupAptSources
    case installDependencies
}

class ExploitChainManager {
    static let shared = ExploitChainManager()
    var logStore: LogStore? = LogStore.shared
    var installationProgress: ((InstallationProgress) -> Void)?
    
    private(set) var xpcExploitSuccess = false
    private(set) var kernelExploitSuccess = false
    private(set) var pplBypassSuccess = false
    private(set) var fsRemountSuccess = false
    
    // 执行完整漏洞利用链
    func executeFullExploitChain(completion: @escaping (Bool) -> Void) {
        resetExploitStates()
        logStore?.append(message: "启动漏洞利用链...")
        
        // 1. XPC沙箱逃逸
        executeXPCExploit { [weak self] xpcSuccess in
            guard let self = self, xpcSuccess else {
                self?.logStore?.append(message: "XPC沙箱逃逸失败")
                completion(false)
                return
            }
            
            self.xpcExploitSuccess = xpcSuccess
            self.logStore?.append(message: "XPC沙箱逃逸成功")
            
            // 2. 内核漏洞提权
            self.executeKernelExploit { kernelSuccess in
                guard kernelSuccess else {
                    self.logStore?.append(message: "内核提权失败")
                    completion(false)
                    return
                }
                
                self.kernelExploitSuccess = kernelSuccess
                self.logStore?.append(message: "内核提权成功")
                
                // 3. PPL/KTRR/KPP绕过
                self.executePPLBypass { pplSuccess in
                    guard pplSuccess else {
                        self.logStore?.append(message: "PPL绕过失败")
                        completion(false)
                        return
                    }
                    
                    self.pplBypassSuccess = pplSuccess
                    self.logStore?.append(message: "PPL保护绕过成功")
                    
                    // 4. 文件系统重挂载
                    self.executeFilesystemRemount { fsSuccess in
                        guard fsSuccess else {
                            self.logStore?.append(message: "文件系统重挂载失败")
                            completion(false)
                            return
                        }
                        
                        self.fsRemountSuccess = fsSuccess
                        self.logStore?.append(message: "文件系统重挂载成功，准备安装Sileo")
                        
                        // 成功完成所有步骤
                        completion(true)
                    }
                }
            }
        }
    }
    
    // 重置状态
    private func resetExploitStates() {
        xpcExploitSuccess = false
        kernelExploitSuccess = false
        pplBypassSuccess = false
        fsRemountSuccess = false
    }
    
    // XPC服务沙箱逃逸
    func executeXPCExploit(completion: @escaping (Bool) -> Void) {
        logStore?.append(message: "开始执行XPC沙箱逃逸...")
        
        DispatchQueue.global(qos: .userInitiated).async {
            // 尝试多种XPC服务
            let services = [
                "com.apple.mobile.installation.xpc", 
                "com.apple.CoreServices.coreservicesd",
                "com.apple.securityd"
            ]
            
            for service in services {
                if connect_xpc_service(service.cString(using: .utf8)!) {
                    DispatchQueue.main.async {
                        self.logStore?.append(message: "成功连接XPC服务: \(service)")
                        completion(true)
                    }
                    return
                }
            }
            
            DispatchQueue.main.async {
                self.logStore?.append(message: "所有XPC服务连接失败")
                completion(false)
            }
        }
    }
    
    // 内核漏洞提权
    func executeKernelExploit(completion: @escaping (Bool) -> Void) {
        logStore?.append(message: "开始执行内核提权...")
        
        DispatchQueue.global(qos: .userInitiated).async {
            // 调用Objective-C实现的内核漏洞
            let kernelSuccess = trigger_kernel_exploit()
            
            DispatchQueue.main.async {
                completion(kernelSuccess)
            }
        }
    }
    
    // PPL保护绕过
    func executePPLBypass(completion: @escaping (Bool) -> Void) {
        logStore?.append(message: "开始执行PPL保护绕过...")
        
        DispatchQueue.global(qos: .userInitiated).async {
            // 基于设备和iOS版本选择不同的PPL绕过方法
            let osVersion = UIDevice.current.systemVersion
            
            // iOS 17使用PAC绕过
            if osVersion.compare("17.0", options: .numeric) != .orderedAscending {
                let result = bypass_ppl_via_pac()
                DispatchQueue.main.async {
                    completion(result)
                }
            } 
            // iOS 16及以下使用KPP绕过
            else if osVersion.compare("16.0", options: .numeric) != .orderedAscending {
                let result = bypass_kpp_protection()
                DispatchQueue.main.async {
                    completion(result)
                }
            }
            // 其他情况使用硬件辅助方法
            else {
                let result = bypass_ppl_via_hardware_method()
                DispatchQueue.main.async {
                    completion(result)
                }
            }
        }
    }
    
    // 文件系统重挂载
    func executeFilesystemRemount(completion: @escaping (Bool) -> Void) {
        logStore?.append(message: "开始执行文件系统重挂载...")
        
        DispatchQueue.global(qos: .userInitiated).async {
            // 创建越狱环境目录
            self.setupJailbreakEnvironment()
            
            // 重挂载根文件系统为可读写
            let remountSuccess = remount_rootfs_as_rw()
            
            if remountSuccess {
                // 设置越狱环境
                self.setupBaseBin { setupSuccess in
                    if setupSuccess {
                        // 激活BaseBin子系统
                        let initSuccess = self.initializeBaseBin()
                        DispatchQueue.main.async {
                            completion(initSuccess)
                        }
                    } else {
                        DispatchQueue.main.async {
                            completion(false)
                        }
                    }
                }
            } else {
                DispatchQueue.main.async {
                    completion(false)
                }
            }
        }
    }
    
    // 创建越狱环境目录
    private func setupJailbreakEnvironment() {
        logStore?.append(message: "创建越狱环境目录...")
        
        // 确保/var/jb目录结构存在
        let directories = [
            "/var/jb",
            "/var/jb/usr",
            "/var/jb/usr/lib",
            "/var/jb/usr/bin",
            "/var/jb/etc",
            "/var/jb/etc/apt",
            "/var/jb/Library",
            "/var/jb/Applications",
            "/var/jb/basebin"
        ]
        
        for dir in directories {
            do {
                if !FileManager.default.fileExists(atPath: dir) {
                    try FileManager.default.createDirectory(atPath: dir, withIntermediateDirectories: true, attributes: nil)
                    self.logStore?.append(message: "创建目录: \(dir)")
                }
            } catch {
                self.logStore?.append(message: "创建目录失败: \(dir), 错误: \(error.localizedDescription)")
            }
        }
    }
    
    // 设置BaseBin基础环境
    private func setupBaseBin(completion: @escaping (Bool) -> Void) {
        // 解压BaseBin到/var/jb目录
        extractBootstrap { success in
            completion(success)
        }
    }
    
    // 解压基础系统
    private func extractBootstrap(completion: @escaping (Bool) -> Void) {
        DispatchQueue.global(qos: .userInitiated).async {
            let result = extract_bootstrap_to_jb()
            DispatchQueue.main.async {
                completion(result)
            }
        }
    }
    
    // 初始化BaseBin
    private func initializeBaseBin() -> Bool {
        // 创建初始化脚本
        let initScript = """
        #!/bin/sh
        cd /var/jb
        chmod 755 basebin/*
        ./basebin/basebinstart
        """
        
        do {
            let initPath = "/var/jb/initbaseBin.sh"
            try initScript.write(toFile: initPath, atomically: true, encoding: .utf8)
            chmod(initPath, 0o755)
            
            // 使用posix_spawn替代system
            var pid: pid_t = 0
            var fileActions: posix_spawn_file_actions_t?
            posix_spawn_file_actions_init(&fileActions)
            
            let argv: [UnsafeMutablePointer<CChar>?] = [
                strdup(initPath),
                nil
            ]
            
            let envp: [UnsafeMutablePointer<CChar>?] = [
                strdup("PATH=/usr/bin:/bin:/usr/sbin:/sbin:/var/jb/usr/bin"),
                nil
            ]
            
            let spawnStatus = posix_spawn(&pid, initPath, &fileActions, nil, argv, envp)
            
            // 释放内存
            for arg in argv where arg != nil {
                free(arg)
            }
            for env in envp where env != nil {
                free(env)
            }
            
            posix_spawn_file_actions_destroy(&fileActions)
            
            if spawnStatus == 0 {
                // 等待进程完成
                var status: Int32 = 0
                waitpid(pid, &status, 0)
                return status == 0
            } else {
                logStore?.append(message: "启动初始化脚本失败: \(spawnStatus)")
                return false
            }
        } catch {
            logStore?.append(message: "创建初始化脚本失败: \(error.localizedDescription)")
            return false
        }
    }
    
    // 下载Sileo
    func downloadSileo(completion: @escaping (Bool, String?) -> Void) {
        let documentsDirectory = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first!
        let destinationPath = documentsDirectory.appendingPathComponent("sileo.deb").path
        let urlString = "https://github.com/Sileo/Sileo/releases/download/2.4.4/org.coolstar.sileo_2.4.4_iphoneos-arm64.deb"
        
        guard let url = URL(string: urlString) else {
            logStore?.append(message: "无效的Sileo下载URL")
            completion(false, nil)
            return
        }
        
        installationProgress?(.downloadingSileo)
        logStore?.append(message: "开始下载Sileo...")
        
        let task = URLSession.shared.downloadTask(with: url) { tempURL, response, error in
            guard let tempURL = tempURL, error == nil else {
                self.logStore?.append(message: "下载Sileo失败: \(error?.localizedDescription ?? "未知错误")")
                completion(false, nil)
                return
            }
            
            do {
                // 移动下载的文件到目标路径
                if FileManager.default.fileExists(atPath: destinationPath) {
                    try FileManager.default.removeItem(atPath: destinationPath)
                }
                try FileManager.default.moveItem(at: tempURL, to: URL(fileURLWithPath: destinationPath))
                
                self.logStore?.append(message: "Sileo下载完成: \(destinationPath)")
                completion(true, destinationPath)
            } catch {
                self.logStore?.append(message: "处理Sileo包失败: \(error.localizedDescription)")
                completion(false, nil)
            }
        }
        
        task.resume()
    }
    
    // 准备畸形MP4文件以触发漏洞
    func prepareCorruptedMP4File(completion: @escaping (Bool, URL?) -> Void) {
        let tempDir = FileManager.default.temporaryDirectory
        let fileURL = tempDir.appendingPathComponent("exploit-\(UUID().uuidString).mp4")
        
        do {
            // 创建畸形MP4文件内容
            let malformedData = createMalformedMP4Data()
            try malformedData.write(to: fileURL)
            
            // 验证文件是否创建成功
            if FileManager.default.fileExists(atPath: fileURL.path) {
                logStore?.append(message: "已创建畸形MP4文件: \(fileURL.lastPathComponent)")
                completion(true, fileURL)
            } else {
                logStore?.append(message: "创建畸形MP4文件失败")
                completion(false, nil)
            }
        } catch {
            logStore?.append(message: "创建畸形MP4文件出错: \(error.localizedDescription)")
            completion(false, nil)
        }
    }
    
    // 创建畸形MP4数据
    private func createMalformedMP4Data() -> Data {
        // 创建基本MP4文件头
        var data = Data([0x00, 0x00, 0x00, 0x18, 0x66, 0x74, 0x79, 0x70, 0x6D, 0x70, 0x34, 0x32])
        
        // 添加畸形MOOV部分
        let moovHeader: [UInt8] = [0x00, 0x00, 0x0F, 0xFF, 0x6D, 0x6F, 0x6F, 0x76]
        data.append(contentsOf: moovHeader)
        
        // 添加特定的畸形数据以触发漏洞
        for _ in 0..<1024 {
            data.append(contentsOf: [0x41, 0x41, 0x41, 0x41])
        }
        
        return data
    }
}
